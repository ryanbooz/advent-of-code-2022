create table dec10 (
	id integer generated by default as identity,
	line text
);


-- COPY the text into the appropriate columns
\COPY dec10 (line) FROM input_10.txt NULL '';

select * from dec10;

TRUNCATE dec10;

with recursive s as (select $$addx 15
addx -11
addx 6
addx -3
addx 5
addx -1
addx -8
addx 13
addx 4
noop
addx -1
addx 5
addx -1
addx 5
addx -1
addx 5
addx -1
addx 5
addx -1
addx -35
addx 1
addx 24
addx -19
addx 1
addx 16
addx -11
noop
noop
addx 21
addx -15
noop
noop
addx -3
addx 9
addx 1
addx -3
addx 8
addx 1
addx 5
noop
noop
noop
noop
noop
addx -36
noop
addx 1
addx 7
noop
noop
noop
addx 2
addx 6
noop
noop
noop
noop
noop
addx 1
noop
noop
addx 7
addx 1
noop
addx -13
addx 13
addx 7
noop
addx 1
addx -33
noop
noop
noop
addx 2
noop
noop
noop
addx 8
noop
addx -1
addx 2
addx 1
noop
addx 17
addx -9
addx 1
addx 1
addx -3
addx 11
noop
noop
addx 1
noop
addx 1
noop
noop
addx -13
addx -19
addx 1
addx 3
addx 26
addx -30
addx 12
addx -1
addx 3
addx 1
noop
noop
noop
addx -9
addx 18
addx 1
addx 2
noop
noop
addx 9
noop
noop
noop
addx -1
addx 2
addx -37
addx 1
addx 3
noop
addx 15
addx -21
addx 22
addx -6
addx 1
noop
addx 2
addx 1
noop
addx -10
noop
noop
addx 20
addx 1
addx 2
addx 2
addx -6
addx -11
noop
noop
noop
$$ as a
)
insert into dec10 (line)
select regexp_split_to_table(trim(both E' \n' from a),'\n')
 from s;

SELECT * FROM dec10;

truncate dec10;

/**************************
 * Star 1
 **************************/
with recursive sig (id, instruct) as (
	select id, regexp_split_to_array(line, ' ') from dec10
)
--SELECT * FROM sig;
,
registers (id, cycle, value, istart, instruct) as (
	select id, 1::bigint, 1::bigint, true, instruct from sig where id = (select min(id) from sig)
	--
	union all
	--
	select 
		case when r.istart = true then r.id else r.id+1 end,
		r.cycle+1,	
		case when r.instruct[1]='noop' then r.value
			when istart = false then r.value else r.value + r.instruct[2]::bigint end,
		case when s.instruct[1]='addx' and istart = false then true else false end,
		case when istart = false then s.instruct else r.instruct end
	from registers r
	join sig s on r.id+1 = s.id
)
select * from registers;
select sum(cycle*value) total from registers
where cycle = any('{20,60,100,140,180,220}');

/*
 * Once again, Vik had a much more elegant solution. I had actually
 * started with 'string_to_table' but didn't know how I'd get
 * the start/stop of the 'addx' commands to work.
 * 
 * So much easier!
 */
SELECT ROW_NUMBER() OVER (ORDER BY d.id, s.ord) cycle,
       CASE WHEN s.ord = 2 THEN CAST(s.v AS INTEGER) END
FROM dec10 AS d
CROSS JOIN LATERAL string_to_table(d.line, ' ') WITH ORDINALITY AS s (v, ord)


/**************************
 * Star 2
 **************************/
with recursive sig (id, instruct) as (
	select id, regexp_split_to_array(line, ' ') from dec10
),
registers (id, cycle, value, istart, instruct, sprite) as (
	select id::bigint, 0::bigint,1::bigint, true, instruct, '{0,1,2}'::bigint[] from sig where id = (select min(id) from sig)
	--
	union all
	--
	select case when r.istart = true then r.id else r.id+1 end, 
		r.cycle+1,
		case when r.instruct[1]='noop' then r.value
			when istart = false then r.value else r.value + r.instruct[2]::bigint end,
		case when s.instruct[1]='addx' and istart = false then true else false end,
		case when istart = false then s.instruct else r.instruct END,
		case when istart = true then r.sprite else ARRAY[r.value-1, r.value,r.value+1] END
	from registers r
	join sig s on r.id+1 = s.id
)
--select * from registers;
select r, STRING_AGG(pixel,'') from ( 
	select *,
		case when CYCLE = any(s.p) then '#' else '.' end pixel
	from registers
	cross join lateral
		(VALUES ((CYCLE/40)*40)) crt(r)
	cross join lateral
		--(VALUES (array[value+crt.r-1,value+crt.r,value+crt.r+1])) as s(p)
		(VALUES (array[sprite[1]+crt.r,sprite[2]+crt.r,sprite[3]+crt.r])) as s(p)
) a
group by r
order by r;