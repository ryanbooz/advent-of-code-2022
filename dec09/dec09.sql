/**************************
 * Star 1
 **************************/

/*
 * I decided to start by inserting the test data
 * first because pulling it apart in text form
 * required an extra step to filter out additional
 * carriage returns. Since I'll be pulling it from
 * the table in the end, figured I'd do it this way.
 */

drop table IF EXISTS dec09;

create table dec09 (
	id integer generated by default as identity,
	line text
);


-- COPY the text into the appropriate columns
\COPY dec09 (line) FROM input_09.txt NULL '';

select * from dec09;

/*
 * Now insert test data.
 */

truncate dec09;

with recursive s as (select $$R 4
U 4
L 3
D 1
R 4
D 1
L 5
R 2
$$ as a
)
insert into dec09 (line)
select regexp_split_to_table(trim(both E' \n' from a),'\n')
 from s;

SELECT * FROM dec09;

-- We need to get the direction and step count
-- This could be done with regexp_split_to_array() for more complicated
-- regex needs, but we're just splitting on a single character here. 
SELECT * FROM dec09,
	string_to_array(line,' ') AS t(lines);


/*
 * Once again, I need to go back to middle school. I didn't
 * read the instructions carefully enough and got distracted
 * by trying to just make each jump in total each time.
 */
with recursive movement (dir, hx, hy) as ( 
	VALUES ('U',0,1),
		   ('D',0,-1),
		   ('L',-1,0),
		   ('R',1,0)
),
hmove (id, lines, dir, hx, hy) as (
 -- think of "id" as instruction. Each row tells us what to do for this instruction.
 select id, lines, dir, hx*lines[2]::int, hy*lines[2]::int
 from dec09 d,
 	string_to_array(line, ' ') as t(lines)
 join movement m on m.dir = lines[1]
)
--select * from hmove;
,
tmove (id, mx, my, hx, hy, tx, ty) as (
	select min(id)-1::int, 0,0,0,0,0,0 from hmove
	--
	UNION ALL 
	--
	select h.id, 
		h.hx, h.hy,
		tm.hx+h.hx,
		tm.hy+h.hy,
		case when abs(tm.hx+h.hx - tm.tx) > 1 then 
			(tm.hx+h.hx)-1
		else tm.tx end,
		case when abs(tm.hy+h.hy - tm.ty) > 1 then 
			(tm.hy+h.hy)-1
		else tm.ty end			
	from tmove tm 
	join hmove h on tm.id+1 = h.id
)
--select * from tmove;
select count(distinct (tx,ty)) from tmove;


/*
 * Learning from my mistakes. Thanks to Vik Fearing
 * for the helpful example of how to use CROSS JOIN LATERAL
 * to simplify some references elsewhere.
 */
-- star 1
with recursive movement (dir, hx, hy) as ( 
	VALUES ('U',0,1),
		   ('D',0,-1),
		   ('L',-1,0),
		   ('R',1,0)
),
hmove (step,id, lines, dir, x, y) as (
 select row_number() over(order by id) step, 
 	id, lines, dir, hx, hy
 from dec09 d,
 	regexp_split_to_array(line, ' ') as t(lines)
 join movement m on m.dir = lines[1],
 	generate_series(1,lines[2]::int)
)
--select * from hmove;
,
tmove (step, mx, my, hx, hy, tx, ty) as (
	SELECT 0::bigint,0,0,0,0,0,0
	--
	UNION ALL 
	--
	select hm.step, 
		hm.x, hm.y,
		h.x, h.y,
		t.x, t.y
	from tmove tm 
	join hmove hm on tm.step+1 = hm.step
	cross join lateral
		(VALUES (tm.hx+hm.x, tm.hy+hm.y)) as h(x,y) -- This can be referenced above AND below
	cross join lateral
		(VALUES (
			case when abs(h.y-tm.ty) = 2 then h.x
				when abs(tm.tx-h.x) <= 1 then tm.tx
			else tm.tx + hm.x end,
			case when abs(h.x-tm.tx) = 2 then h.y
				when abs(tm.ty-h.y) <= 1 then tm.ty
			else tm.ty + hm.y end
		)) t(x,y)	
	where hm.step <= (select max(step) from hmove)
)
--select * from tmove;
select count(distinct (tx,ty)) from tmove;




/*
 * Data for star 2 testing
 */
truncate dec09;

with recursive s as (select $$R 5
U 8
L 8
D 3
R 17
D 10
L 25
U 20
$$ as a
)
insert into dec09 (line)
select regexp_split_to_table(trim(both E' \n' from a),'\n')
 from s;



/**************************
 * Star 2
 **************************/

/*
 * I have left some commented out SQL here to show/remind
 * myself how I got here. :-) 
 * 
 * Original successful run with a full "knots" table of 115k rows
 * took ~25 minutes on my machine with Postgres running Docker
 * 
 * By eliminating the need to progressively scan 115k rows of 
 * data every time, and simply working through "steps" instead
 * (1/10th the rows), runtime is 1.5 minutes.
 * 
 * Also, using the CROSS JOIN LATERAL trick really is helpful
 * for more clearly working with data higher up. Yes, it adds some
 * work, but at least in this form it was helpful
 */
--EXPLAIN analyze
with recursive movement (dir, hx, hy) as ( 
	VALUES ('U',0,1),
		   ('D',0,-1),
		   ('L',-1,0),
		   ('R',1,0)
),
steps (knot, step, id, lines, dir, dirx, diry) as (
	select 1::int, row_number() over(order by id) step, 
	 	id, lines, dir, hx, hy
	 from dec09 d,
	 	regexp_split_to_array(line, ' ') as t(lines)
	 join movement m on m.dir = lines[1],
	 	generate_series(1,lines[2]::int)
)
--select * from steps;
,
knots (knot, step, dirx, diry) as ( 
	select p.knot, p.step, dirx, diry from (
		select g.knot, step from steps,
		generate_series(1,10) g(knot)
	) p
	left join steps s on p.knot = s.knot
		and s.step = p.step
)
--select count(*) from knots
--order by step;
--insert into knots_temp
--select * from knots where knot=1;
,
--explain (analyze,buffers)
--with recursive 
tmove (knot, prevknot, step, prevstep, dirx, diry, pos,x,y) as (
	select knot, 10::bigint, step, 0::bigint, dirx, diry, (array[dirx, diry] ||  array_fill(0,array[9,2])),0,0
	from knots where knot = 1 and step = 1
	--
	union
	--
	select 
		-- A few of these rows aren't needed, but were helpful for
		-- seeing data as I figured this out.
		case when tm.knot < 10 then tm.knot+1 else 1 end,
		tm.knot,
		case when tm.knot < 10 then tm.step else tm.step + 1 end, 
		tm.step,
		k.dirx, 
		k.diry,
		case when tm.knot = 10 then array[tm.pos[1][1]+k.dirx,tm.pos[1][2]+k.diry] || pos[2:]
			when tm.knot = 9 then  pos[1:tm.knot] || array[t.x,t.y] 
		 	else  pos[1:tm.knot] || array[t.x,t.y] || pos[tm.knot+2:]
			end
		end,
		t.x, t.y
	from tmove tm 
	join knots k on 
		CASE WHEN tm.knot = 10 THEN k.knot = 1 ELSE k.knot=tm.knot+1 END
		AND tm.step = k.step
	cross join lateral
		(VALUES (tm.pos[tm.knot][1], tm.pos[tm.knot][2], tm.pos[tm.knot+1][1],tm.pos[tm.knot+1][2])) as kn(px,py,x,y)
	cross join lateral
		(VALUES (
			/*
			 * This formula made a lot more sense than what I was trying to do
			 * again thanks for Vik Fearing
			 */
			CASE WHEN abs(kn.py-kn.y) = 2 AND NOT abs(kn.px-kn.x) = 2 THEN kn.px 
				ELSE kn.x + (kn.px - kn.x) / 2 END,
	        CASE WHEN abs(kn.px-kn.x) = 2 AND NOT abs(kn.py-kn.y) = 2 THEN kn.py 
				ELSE kn.y + (kn.py - kn.y) / 2 END		
--			case when abs(tm.pos[tm.knot][2]-tm.pos[tm.knot+1][2]) = 2 then tm.pos[tm.knot][1]
--				when abs(tm.pos[tm.knot][1]-tm.pos[tm.knot+1][1]) <= 1 then tm.pos[tm.knot+1][1]
--			else tm.pos[tm.knot+1][1] + coalesce(nullif(tm.dirx,0),nullif(tm.diry,0)) end,
--			case when abs(tm.pos[tm.knot][1]-tm.pos[tm.knot+1][1]) = 2 then tm.pos[tm.knot][2]
--				when abs(tm.pos[tm.knot][2]-tm.pos[tm.knot+1][2]) <= 1 then tm.pos[tm.knot+1][2]
--			else tm.pos[tm.knot+1][2] + coalesce(nullif(tm.diry,0),nullif(tm.dirx,0)) end
		)) t(x,y)
	where k.step <= (select max(step) from steps)
)
--select * from tmove;
select count(distinct(pos[10:10])) from tmove; 

set work_mem='512MB';
show work_mem;


-- A better solution. Remove the intermediate 'knots' table
-- that has to scan 115k rows every time on the join!
SET jit=ON;
--EXPLAIN analyze
with recursive movement (dir, hx, hy) as ( 
	VALUES ('U',0,1),
		   ('D',0,-1),
		   ('L',-1,0),
		   ('R',1,0)
),
steps (knot, step, id, lines, dir, dirx, diry) as (
	select 1::int, row_number() over(order by id) step, 
	 	id, lines, dir, hx, hy
	 from dec09 d,
	 	regexp_split_to_array(line, ' ') as t(lines)
	 join movement m on m.dir = lines[1],
	 	generate_series(1,lines[2]::int)
)
--select * from steps;
,
tmove (knot, prevknot, step, prevstep, dirx, diry, pos,x,y) as (
	select knot, 10::bigint, 0::bigint, 0::bigint, dirx, diry, array_fill(0,array[10,2]),0,0
	from steps where knot = 1 and step = 1
	--
	union
	--
	select 
		-- A few of these rows aren't needed, but were helpful for
		-- seeing data as I figured this out.
		case when tm.knot < 10 then tm.knot+1 else 1 end,
		tm.knot,
		case when tm.knot < 10 then tm.step else tm.step + 1 end, 
		tm.step,
		k.dirx,
		k.diry,
		case when tm.knot = 10 then array[tm.pos[1][1]+k.dirx,tm.pos[1][2]+k.diry] || pos[2:]
			when tm.knot = 9 then  pos[1:tm.knot] || array[t.x,t.y] 
		 	else  pos[1:tm.knot] || array[t.x,t.y] || pos[tm.knot+2:]
			end
		end,
		t.x, t.y
	from tmove tm 
	join steps k on tm.step+1 = k.step
	cross join lateral
		(VALUES (tm.pos[tm.knot][1], tm.pos[tm.knot][2], tm.pos[tm.knot+1][1],tm.pos[tm.knot+1][2])) as kn(px,py,x,y)
	cross join lateral
		(VALUES (
			/*
			 * This formula made a lot more sense than what I was trying to do
			 * again thanks for Vik Fearing
			 */
			CASE WHEN abs(kn.py-kn.y) = 2 AND NOT abs(kn.px-kn.x) = 2 THEN kn.px 
				ELSE kn.x + (kn.px - kn.x) / 2 END,
	        CASE WHEN abs(kn.px-kn.x) = 2 AND NOT abs(kn.py-kn.y) = 2 THEN kn.py 
				ELSE kn.y + (kn.py - kn.y) / 2 END		
		)) t(x,y)
	where k.step <= (select max(step) from steps)
)
--select * from tmove;
select count(distinct(pos[10:10])) from tmove;