create table dec07 (
	id integer generated by default as identity,
	file_system text
);

-- COPY the text into the appropriate columns
\COPY dec07 (file_system) FROM input_07.txt NULL '';

select * from dec07;

with recursive commands as (
	select id,
		regexp_match(file_system, '\$ cd (.*)') as dir,
		regexp_match(file_system,'([\d]+) (.*)') as file from dec07
),
walk_tree as (
	select 1::int id,
		'{}'::text[] as dir, 
		null::text file,
		null::int fsize	
	union all
	select c.id+1, 
		case when c.dir[1] != '..' and c.dir is not null 
			then wt.dir || c.dir[1]
		when c.dir[1] = '..' THEN 
			trim_array(wt.dir,1)
			--wt.dir[1:array_length(wt.dir,1)-1]
		else wt.dir end dir,
		c.file[2], c.file[1]::int
	from commands c
		join walk_tree wt on c.id = wt.id
),
paths (dir) as (
	select distinct dir
	from walk_tree 
	where CARDINALITY(dir) > 0
),
sizes(dir, size) as (
	select p.dir, sum(fsize)
	from paths as p
	join walk_tree wt on wt.dir[:CARDINALITY(p.dir)] = p.dir
	group by p.dir
)
select sum(size) as first_star
from sizes
where size < 100000;



with recursive commands as (
	select id,
		regexp_match(file_system, '\$ cd (.*)') as dir,
		regexp_match(file_system,'([\d]+) (.*)') as file from dec07
),
walk_tree as (
	select 0::int id,
		'{}'::text[] as dir, 
		null::text file,
		null::int fsize
	union all
	select c.id, 
		case when c.dir[1] != '..' and c.dir is not null 
			then wt.dir || c.dir[1]
		when c.dir[1] = '..' THEN 
			trim_array(wt.dir,1)
			--wt.dir[1:array_length(wt.dir,1)-1]
		else wt.dir end dir,
		c.file[2], c.file[1]::int
	from commands c 
		join walk_tree wt on c.id = wt.id+1
),
paths (dir) as (
	select distinct dir
	from WALK_TREE 
	where CARDINALITY(dir) > 0
),
sizes(dir, size) as (
	select p.dir, sum(fsize)
	from paths as p
	join WALK_TREE wt on wt.dir[:CARDINALITY(p.dir)] = p.dir
	group by p.dir
),
space_needed as (
	select dir, size, 70000000-size free_space
	from sizes
	where CARDINALITY(dir) = 1
)
select * from sizes
 where size > (select 30000000-free_space from space_needed)
order by size;





select sum(dir_total) from (
	select dir, sum(fsize) dir_total from (
		select distinct on (tt.dir, wt.file) tt.dir, wt.file, wt.fsize from walk_tree wt
			join walk_tree tt on wt.dir[:cardinality(tt.dir)] = tt.dir
			where 
			wt.file is not null and tt.file is not null
	) a
	group by dir
) b
where dir_total < 100000;

select dir, sum(fsize) dir_total from (
		select distinct on (tt.dir, wt.file) tt.dir, wt.file, wt.fsize from walk_tree wt
			join walk_tree tt on wt.dir[:cardinality(tt.dir)] = tt.dir
			where 
			wt.file is not null and tt.file is not null
	) a
	group by dir;

select distinct on (tt.dir, wt.file) tt.dir, wt.file, wt.fsize from walk_tree wt
	join walk_tree tt on wt.dir[:cardinality(tt.dir)] = tt.dir
	where 
	wt.file is not null and tt.file is not null


select sum(dir_total) from (
	select dir, sum(fsize) dir_total from (
		select distinct on (tt.dir, wt.file) tt.dir, wt.file, wt.fsize from walk_tree wt
			join walk_tree tt on wt.dir[:cardinality(tt.dir)] = tt.dir
			where 
			wt.file is not null and tt.file is not null
	) a
	group by dir
) b
where dir_total < 100000;

select * from walk_tree;

